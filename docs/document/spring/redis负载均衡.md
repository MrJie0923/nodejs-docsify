## Redis集群配置参数

* **cluster-enabled**：如果是，则在特定的Redis实例中启用Redis Cluster支持。否则，该实例将像往常一样作为独立实例启动。
* **cluster-config-file**：请注意，尽管有此选项的名称，但它不是用户可编辑的配置文件，而是Redis Cluster节点每次发生更改时都会自动持久保存集群配置的文件（状态，基本上是状态），为了能够在启动时重新阅读它。该文件列出了诸如集群中其他节点之类的东西，它们的状态，持久变量等等。通常，由于收到某些消息，此文件将被重写并刷新到磁盘上。
* **cluster-node-timeout**：Redis群集节点不可用的最长时间（不将其视为失败）。如果主节点无法访问的时间超过指定的时间量，则其主节点将对其进行故障转移。此参数控制Redis Cluster中的其他重要内容。值得注意的是，在指定的时间内无法到达大多数主节点的每个节点都将停止接受查询。
* **cluster-slave-validity-factor``**：如果设置为零，则从服务器将始终尝试对主服务器进行故障转移，而不管主服务器和从服务器之间的链接保持断开状态的时间长短。如果该值为正，则将最大断开时间计算为*节点超时*值乘以此选项提供的因子，如果节点是从节点，则如果断开主链接的时间超过指定的时间，它将不会尝试启动故障转移。例如，如果节点超时设置为5秒，而有效性因子设置为10，则从服务器与主服务器断开连接超过50秒将不会尝试对其主服务器进行故障转移。请注意，如果没有从属能够对其进行故障转移，则任何不为零的值都可能导致Redis Cluster在主控发生故障后不可用。在这种情况下，只有当原始主服务器重新加入群集后，群集才会恢复可用。
* **cluster-migration-barrier``**：主机将保持连接的最小数量的从机，以便另一个从机迁移到不再受任何从机覆盖的主机。有关更多信息，请参见本教程中有关副本迁移的相应部分。
* **cluster-require-full-coverage``**：如果设置为yes，默认情况下，如果某个节点没有覆盖一定比例的密钥空间，集群将停止接受写入。如果该选项设置为no，即使仅可以处理有关密钥子集的请求，群集仍将提供查询。
* **cluster-allow-reads-when-down``**：如果将其设置为no（默认情况下为默认值），则当Redis群集被标记为失败时，或者当某个节点无法到达时，Redis群集中的节点将停止提供所有流量达不到法定人数或完全覆盖。这样可以防止从不知道群集更改的节点读取可能不一致的数据。可以将此选项设置为yes，以允许在失败状态期间从节点进行读取，这对于希望优先考虑读取可用性但仍希望防止写入不一致的应用程序很有用。当仅使用一个或两个分片的Redis Cluster时，也可以使用它，因为它允许节点在主服务器发生故障但无法进行自动故障转移时继续为写入提供服务。



##  创建和使用Redis集群

注意：要手动部署Redis群集**，了解其**某些操作方面**非常重要**。但是，如果要尽快建立集群并运行（尽快），请跳过本节和下一节，直接转到**使用create-cluster脚本创建Redis集群**。

要创建集群，我们需要做的第一件事就是让一些空的Redis实例在**集群模式**下运行。基本上，这意味着不使用常规Redis实例创建集群，因为需要配置特殊模式，以便Redis实例将启用集群特定的功能和命令。

以下是最小的Redis群集配置文件：

```properties
port 7000
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
```

如您所见，启用集群模式的只是`cluster-enabled` 指令。每个实例还包含该节点的配置存储位置的文件路径，默认情况下为`nodes.conf`。该文件永远不会被人类触及。它仅在启动时由Redis Cluster实例生成，并在需要时进行更新。

请注意，按预期工作的**最小群集**要求至少包含三个主节点。对于您的第一个测试，强烈建议启动一个由三个主节点和三个从节点组成的六个节点群集。

为此，输入一个新目录，并创建以下目录，该目录以我们将在任何给定目录中运行的实例的端口号命名。

就像是：

```properties
mkdir cluster-test
cd cluster-test
mkdir 7000 7001 7002 7003 7004 7005
```

`redis.conf`在每个目录（从7000到7005）中创建一个文件。作为配置文件的模板，只需使用上面的小示例，但请确保`7000`根据目录名称用正确的端口号替换端口号。

现在，将您的redis-server可执行文件（**从GitHub不稳定分支中的最新资源编译而来）**复制到`cluster-test`目录中，最后在您喜欢的终端应用程序中打开6个终端选项卡。

像这样启动每个实例，每个选项卡一个：

```properties
cd 7000
../redis-server ./redis.conf
```

从每个实例的日志中可以看到，由于不`nodes.conf`存在文件，因此每个节点都会为其分配一个新的ID。

## 创建集群

现在我们有许多实例正在运行，我们需要通过向节点写入一些有意义的配置来创建集群。

如果您使用的是Redis 5，这很容易完成，这是因为嵌入到中的Redis Cluster命令行实用程序为我们提供了帮助，该实用程序`redis-cli`可用于创建新集群，检查或重新分片现有集群等。

对于Redis版本3或4，有一个称为的旧工具`redis-trib.rb`，它非常相似。您可以`src`在Redis源代码分发的目录中找到它。您需要安装`redis`gem才能运行`redis-trib`。

```properties
gem install redis
```

第一个示例，即集群创建，将`redis-cli`在Redis 5和`redis-trib`Redis 3和4中同时使用。但是，所有下一个示例将仅使用`redis-cli`，因为如您所见，语法非常相似，因此您可以轻松地通过`redis-trib.rb help`获取有关旧语法的信息，将一个命令行更改为另一命令行。**重要：**请注意，如果需要，可以`redis-cli`对Redis 4群集使用Redis 5 ，而不会出现问题。

`redis-cli`只需键入以下内容即可为Redis 5创建集群：

```properties
redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \
127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \
--cluster-replicas 1
```

此处使用的命令是**create**，因为我们要创建一个新集群。该选项`--cluster-replicas 1`意味着我们希望为每个创建的主机都提供一个从机。其他参数是我要用于创建新集群的实例的地址列表。

显然，满足我们要求的唯一设置是创建具有3个主设备和3个从设备的集群。

Redis-cli将为您提出配置。输入**yes**接受建议的配置。集群将被配置并*加入*，这意味着实例将被引导成彼此对话。最后，如果一切顺利，您将看到如下消息：

> ```
> [OK] All 16384 slots covered
> ```

##  使用create-cluster脚本创建Redis集群

如果您不想如上所述通过手动配置和执行单个实例来创建Redis集群，则可以使用一个简单得多的系统（但是您将不会学到相同数量的操作细节）。

只需检查`utils/create-cluster`Redis发行版中的目录即可。`create-cluster`内部有一个脚本（名称与包含在其中的目录相同），它是一个简单的bash脚本。为了启动具有3个主节点和3个从节点的6节点群集，只需键入以下命令：

1. `create-cluster start`
2. `create-cluster create`

`yes`当`redis-cli`实用程序希望您接受群集布局时，请在步骤2中进行答复。

现在，您可以与集群进行交互，默认情况下，第一个节点将从端口30001开始。完成后，使用以下命令停止集群：

1. `create-cluster stop`。

请阅读`README`此目录内的内容，以获取有关如何运行脚本的更多信息。

## 添加一个新节点

添加新节点基本上是以下过程：添加一个空节点，然后将一些数据移入该节点（如果它是新的主节点），或者告诉它设置为已知节点的副本（如果它是从节点的话）。

从添加新的主实例开始，我们将展示两者。

在这两种情况下，要执行的第一步都是**添加一个空节点**。

就像在端口7006中启动一个新节点一样简单（对于现有6个节点，我们已经从7000到7005使用了新节点），除了端口号以外，其他节点使用了相同的配置，因此您应该按顺序进行操作符合我们先前节点使用的设置：

- 在终端应用程序中创建一个新选项卡。
- 输入`cluster-test`目录。
- 创建一个名为的目录`7006`。
- 在内部创建一个redis.conf文件，类似于用于其他节点的文件，但使用7006作为端口号。
- 最后用以下命令启动服务器 `../redis-server ./redis.conf`

此时服务器应该正在运行。

现在，我们可以像往常一样使用**redis-cli**来将节点添加到现有集群中。

```properties
redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000
```

如您所见，我使用**add-node**命令将新节点的地址指定为第一个参数，并将集群中随机存在的节点的地址指定为第二个参数。

实际上，redis-cli在这里对我们没有什么帮助，它只是向节点发送了[CLUSTER MEET](https://redis.io/commands/cluster-meet)消息，这也可以手动完成。但是redis-cli也会在运行之前检查集群的状态，因此，即使您知道内部结构如何运行，也始终通过redis-cli执行集群操作是一个好主意。

现在，我们可以连接到新节点，以查看它是否确实加入了集群：

```
redis 127.0.0.1:7006> cluster nodes
3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921
3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected
f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected
a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected
97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422
3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383
```

请注意，由于此节点已经连接到集群，因此它已经能够正确重定向客户端查询，并且通常来说是集群的一部分。但是，与其他大师相比，它有两个特点：

- 由于没有分配的哈希槽，因此不保存任何数据。
- 因为它是一个没有分配插槽的主机，所以当从机要成为主机时，它不会参与选举过程。

现在可以使用的重新分片功能为此节点分配哈希槽`redis-cli`。基本上没有必要像我们在上一节中所做的那样显示这一点，没有区别，只是将空节点作为目标进行重新分片。

## 添加新节点作为副本

可以通过两种方式添加新副本。显而易见的是再次使用redis-cli，但是使用--cluster-slave选项，如下所示：

```
redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave
```

请注意，此处的命令行与我们用于添加新主服务器的命令行完全相同，因此我们并未指定要向其添加副本的主服务器。在这种情况下，发生的事情是redis-cli将新节点添加为副本较少的主节点中的随机主节点的副本。

但是，您可以使用以下命令行确切指定要与新副本一起使用的主数据库：

```
redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave --cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
```

这样，我们将新副本分配给特定的主数据库。

将副本添加到特定主副本的一种更手动的方法是将新节点添加为空的主副本，然后使用[CLUSTER REPLICATE](https://redis.io/commands/cluster-replicate)命令将其转换为副本 。如果将该节点添加为从属节点，但您希望将其作为其他主节点的副本进行移动，则这也适用。

例如，为了添加节点127.0.0.1:7005的副本，该副本当前正在11423-16383范围内的哈希槽中，节点ID为3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e，我要做的就是与新节点连接（已经添加为空的主服务器）并发送命令：

```
redis 127.0.0.1:7006> cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
```

而已。现在，我们为这组哈希槽有了一个新副本，并且集群中的所有其他节点都已经知道（在更新其配置几秒钟之后）。我们可以使用以下命令进行验证：

```properties
$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected
```

### 数据迁移

Redis Cluster中的数据迁移又称作`Reshard`，一般是因为有节点的变化或者是做`load balancing`。简单的讲，Reshard就是把一些`slots`从一个节点转移到另一个节点。

`Reshard`的原理并不复杂：

1. 外部工具向某分片发出`migrate`命令，触发一个或者多个（3.2开始支持）key的迁移。
2. 接收到`migrate`命令的分片，即迁出分片，将对应的key进行序列化后发往迁入分片，并阻塞等待迁入分片的返回。
3. 迁入分片通过`restore-asking`命令将收到的key进行应用，并返回成功给迁出分片。
4. 迁出分片收到应答后，删除对应的key，并将`migrate`命令转化为`del`命令并同步给同步和记录到AOF中供replicas消费，完成迁移。

![Figure-3: Redis Cluster with Replication](http://mysql.taobao.org/monthly/pic/202004/2020-04-27-shu-redis-cluster-reshard.png)

上面图例就是一个Reshard的流程示意，我们用一个`string b`来指代若干个`slots`；图中的数字代表步骤的顺序。

## 删除节点

要删除从节点，只需使用`del-node`redis-cli命令：

```
redis-cli --cluster del-node 127.0.0.1:7000 `<node-id>`
```

第一个参数只是集群中的一个随机节点，第二个参数是您要删除的节点的ID。

您也可以用相同的方法删除主节点，**但是要删除主节点，它必须为空**。如果主节点不为空，则需要先将数据从其重新分片到所有其他主节点。

删除主节点的另一种方法是在其从节点之一上对其执行手动故障转移，并在该节点成为新主节点的从节点之后将其删除。显然，这在您想要减少群集中的主节点的实际数量时无济于事，在这种情况下，需要重新分片。

## 升级Redis集群中的节点

升级从节点很容易，因为您只需要停止节点并使用更新版本的Redis重新启动它即可。如果存在使用从属节点扩展读取的客户端，则在给定的从属节点不可用时，它们应该能够重新连接到其他从属节点。

升级母版要复杂一些，建议的过程是：

1. 使用CLUSTER FAILOVER触发主服务器到其从服务器之一的手动故障转移（请参阅本文档的“手动故障转移”部分）。
2. 等待主机变成从机。
3. 最后，像对从属服务器一样升级节点。
4. 如果要将主节点作为刚刚升级的节点，请触发新的手动故障转移，以将升级后的节点转回为主节点。

按照此过程，您应该先升级一个节点，然后再升级所有节点。



###### 一致性hash算法

![consistent-hashing-algorithm](https://github.com/doocs/advanced-java/raw/master/docs/high-concurrency/images/consistent-hashing-algorithm.png)

### 生产环境中的 Redis 是怎么部署的？

-----

1、你的 Redis 是主从架构？集群架构？用了哪种集群方案？有没有做高可用保证？有没有开启持久化机制确保可以进行数据恢复？线上 Redis 给几个 G 的内存？设置了哪些参数？压测后你们 Redis 集群承载多少 QPS？

> Redis cluster，10 台机器，5 台机器部署了 Redis 主实例，另外 5 台机器部署了 Redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 QPS 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。
>
> 机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。
>
> 5 台机器对外提供读写，一共有 50g 内存。
>
> 因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。
>
> 你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。
>
> 其实大型的公司，会有基础架构的 team 负责缓存集群的运维。